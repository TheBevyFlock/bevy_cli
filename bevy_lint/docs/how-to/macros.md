# How to Handle Macro-Generated Code

When a developer uses a macro from a 3rd-party crate, it generates code that the developer cannot easily change or fix. Macro-generated code will still be linted, but if that code has any issues the developer cannot do anything to fix it beyond adding an `#[allow(...)]` attribute.

Because of this, all `bevy_lint` lint passes should skip code generated by an external macro. This can be done with [`Span::in_external_macro()`]:

```rust
impl<'tcx> LateLintPass<'tcx> for MyLint {
    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {
        // Do not lint this expression if it was generated by an external macro.
        if expr.span.in_external_macro(cx.tcx.sess.source_map()) {
            return;
        }

        // ...
    }
}
```

For more information, please see [Clippy's docs on macros], [the issue about macros], and [the PR that first incorporated these checks].

[`Span::in_external_macro()`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro
[Clippy's docs on macros]: https://doc.rust-lang.org/stable/clippy/development/macro_expansions.html
[the issue about macros]: https://github.com/TheBevyFlock/bevy_cli/issues/167
[the PR that first incorporated these checks]: https://github.com/TheBevyFlock/bevy_cli/pull/263
