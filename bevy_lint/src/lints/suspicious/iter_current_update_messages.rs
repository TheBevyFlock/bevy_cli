//! Checks for calls to `Messages::<T>::iter_current_update_messages()`.
//!
//! # Motivation
//!
//! `Messages::<T>::iter_current_update_messages()` lets you read all of the current messages since
//! `Messages::<T>::update()` was last called, similar to `MessageReader<T>`. Unlike
//! `MessageReader<T>`, `iter_current_update_messages()` does not track which messages have already
//! been read. As such, `iter_current_update_messages()` is highly discouraged because it may skip
//! messages or yield them multiple times.
//!
//! # Example
//!
//! ```
//! # use bevy::prelude::*;
//! #
//! #[derive(Message)]
//! struct MyMessage;
//!
//! fn my_system(messages: Res<Messages<MyMessage>>) {
//!     for message in messages.iter_current_update_messages() {
//!         // ...
//!     }
//! }
//! ```
//!
//! Use instead:
//!
//! ```
//! # use bevy::prelude::*;
//! #
//! #[derive(Message)]
//! struct MyMessage;
//!
//! fn my_system(mut messages: MessageReader<MyMessage>) {
//!     for message in messages.read() {
//!         // ...
//!     }
//! }
//! ```

use clippy_utils::diagnostics::span_lint_and_help;
use rustc_hir::Expr;
use rustc_lint::{LateContext, LateLintPass};

use crate::{declare_bevy_lint, declare_bevy_lint_pass, sym, utils::method_call::MethodCall};

declare_bevy_lint! {
    pub(crate) ITER_CURRENT_UPDATE_MESSAGES,
    super::Suspicious,
    "called `Messages::<T>::iter_current_update_messages()`",
}

declare_bevy_lint_pass! {
    pub(crate) IterCurrentUpdateMessages => [ITER_CURRENT_UPDATE_MESSAGES],
}

impl<'tcx> LateLintPass<'tcx> for IterCurrentUpdateMessages {
    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {
        // If this expression was generated by an external macro, don't lint it.
        if expr.span.in_external_macro(cx.tcx.sess.source_map()) {
            return;
        }

        if let Some(method_call) = MethodCall::try_from(cx, expr) {
            // Find the adjusted type of the receiver. Type adjustment does things like
            // auto-dereference and type coercion. In this example, we use the adjusted type so
            // that we can also handle `Res<Message<T>>`.
            //
            // ```
            // fn plain(messages: Messages<T>) {
            //     // Original type is `Messages<T>`, adjusted type is `Messages<T>`.
            //     let _ = messages.iter_current_update_messages();
            // }
            //
            // fn res(messages: Res<Messages<T>>) {
            //     // Original type is `Res<Messages<T>>`, adjusted type is `Messages<T>`.
            //     let _ = messages.iter_current_update_messages();
            // }
            // ```
            let src_ty = cx
                .typeck_results()
                .expr_ty_adjusted(method_call.receiver)
                .peel_refs();

            if !crate::paths::MESSAGES.matches_ty(cx, src_ty) {
                return;
            }

            if method_call.method_path.ident.name == sym::iter_current_update_messages {
                span_lint_and_help(
                    cx,
                    ITER_CURRENT_UPDATE_MESSAGES,
                    method_call.span,
                    ITER_CURRENT_UPDATE_MESSAGES.desc,
                    None,
                    "`iter_current_update_messages()` does not track which messages have already been seen, consider using `MessageReader<T>` instead",
                );
            }
        }
    }
}
