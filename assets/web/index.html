<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      /* Styles for the loading screen */
      :root {
        --web-bg-color: #2b2c2f;
        --web-color: white;
      }

      * {
        margin: 0;
        padding: 0;
        border: 0;
      }

      html,
      body {
        width: 100%;
        height: 100%;
      }

      .center {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      body {
        background-color: var(--web-bg-color);
        color: var(--web-color);
      }
      
      canvas {
        outline: none;
        width: 100% !important;
        height: 100% !important;
      }

      .spinner {
        width: 128px;
        height: 128px;
        border: 10px solid transparent;
        border-bottom-color: #ececec;
        border-right-color: #b2b2b2;
        border-top-color: #787878;
        border-radius: 50%;
        box-sizing: border-box;
        animation: spin 1.5s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }

      .bar-container {
        width: 128px;
        height: 12px;
        border: 3px solid #ececec;
        border-radius: 0.375em;
        position: relative;
        overflow: hidden;
        margin-top: 24px;
        margin-bottom: 12px;
      }

      .loading-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #b2b2b2;
        transform-origin: center left;
        transform: scaleX(0);
      }

      .progress-text {
        font-size: 0.9rem;
        color: #ececec;
        font-family:
          DejaVu Sans Mono,
          monospace;
      }

      .error {
        font-size: 0.9rem;
        color: salmon;
        font-family:
          DejaVu Sans Mono,
          monospace;
        margin-top: 12px;
      }
    </style>
  </head>

  <body class="center">
    <noscript>JavaScript support is required to run this app</noscript>
    <div id="loading-screen" class="center">
      <span class="spinner"></span>
      <div hidden="hidden" class="bar-container">
        <div class="loading-bar"></div>
      </div>
      <div class="progress-text"></div>
      <div class="error"></div>
    </div>

    <script type="module">
      // Automatically restart the audio context after user interaction
      // Needs to be executed _before_ the game is loaded
      // Taken from https://developer.chrome.com/blog/web-audio-autoplay/#moving-forward
      (function () {
        // An array of all contexts to resume on the page
        const audioContextList = [];

        // An array of various user interaction events we should listen for
        const userInputEventNames = [
          "click",
          "contextmenu",
          "auxclick",
          "dblclick",
          "mousedown",
          "mouseup",
          "pointerup",
          "touchend",
          "keydown",
          "keyup",
        ];

        // A proxy object to intercept AudioContexts and
        // add them to the array for tracking and resuming later
        self.AudioContext = new Proxy(self.AudioContext, {
          construct(target, args) {
            const result = new target(...args);
            audioContextList.push(result);
            return result;
          },
        });

        // To resume all AudioContexts being tracked
        function resumeAllContexts(event) {
          let count = 0;

          audioContextList.forEach((context) => {
            if (context.state !== "running") {
              context.resume();
            } else {
              count++;
            }
          });

          // If all the AudioContexts have now resumed then we
          // unbind all the event listeners from the page to prevent
          // unnecessary resume attempts
          if (count == audioContextList.length) {
            userInputEventNames.forEach((eventName) => {
              document.removeEventListener(eventName, resumeAllContexts);
            });
          }
        }

        // We bind the resume function for each user interaction
        // event on the page
        userInputEventNames.forEach((eventName) => {
          document.addEventListener(eventName, resumeAllContexts);
        });
      })();
    </script>

    <script type="module">
      // When this file is used as the default `index.html`, the CLI will automatically replace
      // `bevy_app.js` and `bevy_app_bg.wasm` with the name of the generated JS entrypoint and Wasm
      // binary. If you copy this file and customize it, you will need to manually change
      // the names. For more information, please see
      // <https://thebevyflock.github.io/bevy_cli/cli/web/default-index-html.html>!
      import init from "./build/bevy_app.js";
      const wasmPath = "./build/bevy_app_bg.wasm";
      const wasmSize = null;

      // Provide progress reporting when fetching the Wasm binary
      async function fetchWithProgress(url, total, onProgress) {
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`request failed with status ${response.status}`);
        }

        if (total === null) {
          // If the content length isn't provided,
          // we'll just skip the progress reporting
          return await response.arrayBuffer();
        }

        let receivedLength = 0;
        const chunks = [];

        for await (const chunk of response.body) {
          chunks.push(chunk);
          receivedLength += chunk.length;

          const progress = receivedLength / total;

          // Interacting with the DOM or other operations
          // here should not cause downloading to fail
          try {
            onProgress({
              loaded: receivedLength,
              total: total,
              progress: progress,
            });
          } catch (e) {
            console.error(e);
          }
        }

        const chunksAll = new Uint8Array(receivedLength);
        let position = 0;
        for (let chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }

        return chunksAll.buffer;
      }

      function humanReadable(number) {
        // Working with Bevy on the web, we can safely
        // assume this scale
        return `${(number / 1e6).toFixed(2)}MB`;
      }

      async function loadWasm(url, size) {
        let arrayBuffer;
        try {
          arrayBuffer = await fetchWithProgress(url, size, (stats) => {
            const container = document.querySelector(".bar-container");
            container.removeAttribute("hidden");

            const bar = document.querySelector(".loading-bar");
            bar.style.transform = `scaleX(${stats.progress})`;

            const text = document.querySelector(".progress-text");
            text.innerText = `${humanReadable(stats.loaded)} / ${humanReadable(stats.total)}`;
          });
        } catch (e) {
          // Here, we communicate any request failure to the user
          const errorNode = document.querySelector(".error");
          if (errorNode !== null) {
            errorNode.innerText = e.toString();
          }
          throw e;
        }

        return await init(arrayBuffer);
      }

      // Starting the game
      loadWasm(wasmPath, wasmSize).catch((error) => {
        if (
          !error.message.startsWith(
            "Using exceptions for control flow, don't mind me. This isn't actually an error!"
          )
        ) {
          throw error;
        }
      });
    </script>

    <script type="module">
      // Hide loading screen when the game starts.
      const loading_screen = document.getElementById("loading-screen");
      const observer = new MutationObserver((records) => {
        for (const record of records) {
          for (const addedNode of record.addedNodes) {
            if (addedNode instanceof HTMLCanvasElement) {
              if (addedNode.innerText.trim().length === 0) {
                // Add compatibility note
                addedNode.innerText =
                  "Canvas support is required to run this app";
              }

              // A new canvas has been created, which means that the game has been loaded
              // Hide the loading screen!
              loading_screen.style.display = "none";
              observer.disconnect();
              return;
            }
          }
        }
      });

      observer.observe(document.body, {
        subtree: false,
        childList: true,
        attributes: false,
        characterData: false,
      });
    </script>
  </body>
</html>
