use std::{path::Path, process::Command};

use super::arg_builder::ArgBuilder;

pub(crate) const PACKAGE: &str = "wasm-bindgen-cli";
pub(crate) const PROGRAM: &str = "wasm-bindgen";

/// Determine the path to the folder where the Wasm build artifacts are stored.
pub(crate) fn get_target_folder(profile: &str) -> String {
    format!("target/wasm32-unknown-unknown/{profile}")
}

/// Bundle the Wasm build for the web.
pub(crate) fn bundle(package_name: &str, profile: &str) -> anyhow::Result<()> {
    let target_folder = get_target_folder(profile);

    let status = Command::new(PROGRAM)
        .args(
            ArgBuilder::new()
                .arg("--no-typescript")
                .add_with_value("--out-name", "bevy_app")
                .add_with_value("--out-dir", &target_folder)
                .add_with_value("--target", "web")
                .arg(format!("{target_folder}/{package_name}.wasm")),
        )
        .status()?;

    anyhow::ensure!(status.success(), "Failed to bundle project for the web.");
    Ok(())
}

/// Determine if a file path in the target folder is an artifact generated by wasm-bindgen.
pub(crate) fn is_bindgen_artifact(path: &Path) -> bool {
    // The JS interface wrapping the WASM binary
    let js_path = Path::new("bevy_app.js");
    // The WASM bindgen
    let wasm_path = Path::new("bevy_app_bg.wasm");

    path == js_path || path == wasm_path
}
